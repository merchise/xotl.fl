-- This a funny implementation of the semantic equations for pattern matching;
-- funny because they use pattern-matching.

data Match a = FailedMatch | OkMatch a

-- With this implementation Match and Extract change:
-- <Match []> :: [a] -> r -> Match r
-- <Extract 1 for :> :: [a] -> ([a] -> b) -> Match b
-- <Extract 2 for :> :: [a] -> ([a] -> b) -> Match b

-- Then the OR operation would be:

matches :: Match a -> Match a -> Match a
matches Fail        b = b
matches (OkMatch r) _ = OkMatch r

-- But then any expression containing `matches` would have to be somehow
-- unpacked:

match_unpack :: Match a -> a
match_unpack (OkMatch a) = a

-- This `match_unpack` has the "nice" feature that it fails when given Fail.
-- So an expression is just 'match_unpack $ (<Match/Extract ..> ...) `matches`
-- ...)' and does not need the NO_MATCH_ERROR.

-- Of course this is just a funny game, since `matches` and `match_unpack`
-- require pattern matching.

-- Local Variables:
-- mode: haskell
-- End:
